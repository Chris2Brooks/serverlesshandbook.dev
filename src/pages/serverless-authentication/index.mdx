---
title: "Serverless authentication"
description: ""
image: "./img/dealing-with-authentication.png"
---

# Serverless authentication

![](../../images/chapter_headers/dealing-with-authentication.svg)

You've got a feature that only a few people should use. How do you keep it safe?

Authentication. 

It's easy in theory: Save an identifier on the client, send with every request, check against a stored value on the server.

In practice, authentication is hard.

Where do you save the identifier? How does the client get it? What authentication scheme do you use? What goes on the server? How do you keep it secure? What if you need to run authenticated code without the user?

Authentication is a deep rabbit hole. In this chapter, we look at the basics and build 2 examples.

## What is authentication

A typical authentication system deals with everything from user identity, to access control, authorization, and keeping your system secure.

It's a big job :)

**Identity** answers the "Who are you?" question. The most important aspect of authentication systems. Can be as simple as an honor-based input field.

**Access control** answers the "Can you access this system?" question. You ask for proof of identity (like a password) and unlock restricted parts of your app.

**Authorization** answers the "Which parts of the system can you use?" question. Two schemes are common: role-based and scope-based authorization. They specify which users can do what.

**Security** underlies your authentication system. Without security, you've got nothing. 

Typical concerns include leaking authentication tokens, interception attacks, impersonating users, revoking access, how your data behaves, and whether you can identify a breach.

### Factors of authentication

Proof of identity is key to good authentication.

> something the user *knows*, something the user *has*, something the user *is*

Each [authentication factor](https://en.wikipedia.org/wiki/Authentication#Authentication_factors) covers a different overlapping proof of identity. 2 factors is considered safe, 3 is best. Typical is 1 ðŸ™ˆ

**Knowledge factors** include hidden pass phrases like passwords, PINs, and security questions. You know the answer and verify the user also knows.

**Ownership factors** include ID cards, token apps on your phone, physical tokens, and email inboxes. You ask the user to prove they have something only they should have.

**Inference factors** include biometric identifiers like fingerprints, DNA, hand-written signatures, and other markers that uniquely identify a person.

Credit card + PIN is 2-factor authentication. You own the card and know the PIN.

Username + password is 1-factor. You know the username and know the password.

Passwordless email/sms login is 2-factor. You know the username and own the email inbox. Proof by unique link or pin.

### Role-based and scope-based authorization

The 2nd biggest job after access control is authorization. What can *this* user do?

Two flavors of authorization are common:

- **role-based** authorization depends on user types. Admins vs. paid users vs. freeloaders.
- **scope-based** authorization depends on fine-grained user properties. Enable subscriber dashboard or don't.

Technically they're the same â€“Â a user property. It's like utility vs. semantic classes in CSS. Debate until you're blue in the face then pick what feels right :)

Role-based authorization is perfect for small projects. You need admins and everyone else. Being an admin comes with inherent rights.

Scope-based authorization is perfect for large projects with granular needs. Yes you're an admin, but what kind of admin?

In practice you'll see that roles get clunky as your needs grow and scopes are tedious to use. Like when I had permission to configure CloudFront, but not to see what I'm doing. ðŸ™ƒ

At an organizational level you end up with roles that act as bags of scopes. Engineers get scopes x, y, z, admins can do so and so, and users get user things.

## Build your own auth

Let's build a basic serverless auth meant to be used as an API. Best way to get a feel for what it takes.

I'll share and explain the important code, you can [see the full example on GitHub](https://github.com/Swizec/serverlesshandbook.dev/tree/master/examples/serverless-auth-example). Use [this CodeSandbox app](https://codesandbox.io/s/serverless-auth-example-9ipfb) to try it out.

https://codesandbox.io/s/serverless-auth-example-9ipfb

You can use the sandbox to test your implementation. Just replace the Lambda base URL ðŸ˜Š

### The auth flow

The difference between auth for an API and traditional auth comes down to how the client and server talk to each other. Traditional auth uses cookies, API auth relies on [JSON Web Tokens (JWT)](https://jwt.io/).

![Authentication flow](../../images/authentication_flow.png)

We're going to use JWT tokens. It's useful in more situations.

1. User sends username and password
2. Server checks against database
3. Returns fresh JWT token
4. Client adds token to every future request
5. Server checks token is valid before responding

What makes this flow secure is the HTTPS encryption used at the protocol level. Otherwise attackers could sniff user passwords during the first request and steal JWT tokens from subsequent requests.

Always use HTTPS and remember: A JWT token on its own lets you impersonate a user.

### A note on password safety

Part of authentication is storing passwords. You need to know the right password to verify the user got it right.

Passwords are secrets and you should treat them with respect. Don't be the app that leaks a user's common password.

A typical approach is to store passwords using a [one-way hash](https://en.wikipedia.org/wiki/Cryptographic_hash_function). Feed password into a cryptographic function and get a unique value that's impossible to reverse.

Since the invention of [rainbow tables](https://en.wikipedia.org/wiki/Rainbow_table) even one-way hashing is no longer secure. We can fight that with a salt.

```typescript
// src/util.ts

// Hashing your password before saving is critical
// Hashing is one-way meaning you can never guess the password
// Adding a salt and the username guards against common passwords
export function hashPassword(username: string, password: string) {
  return sha256(
    `${password}${process.env.SALT}${username}${password}`
  ).toString()
}
```

Without a salt, the string `password` turns into the same hash for every app. Precomputed rainbow tables work like magic.

With a salt, the string `password` hashes uniquely to *your* app. Attackers need to build new rainbow tables just for you. *If they can find the salt.*

Add the username and each hash is unique to your app *and* the user. Attackers need new rainbow tables for every user. Not worth it.

That's when guessing the user's password becomes easier. You can fight that with limits and timeouts on your login API.

### Environment variables

We need 2 variables to build an auth system:

- a unique SALT for password hashing
- a unique JWT_SECRET for creating JWT tokens

Define them in `serverless.yml` to keep things simple. Use [proper secrets handling](/handling-secrets) for production.

```yaml
# serverless.yml
service: serverless-auth-example

provider:
  # ...
  environment:
    SALT: someRandomSecretString_pleaseUseProperSecrets:)
    JWT_SECRET: useRealSecretsManagementPlease
```

Never share these with anyone. `JWT_SECRET` in particular is all an attacker needs to impersonate a user.

### `auth.login` function

Users need to be able to login â€“Â send an API request with their username and password to get a JWT token. We'll keep it similar to the [REST API chapter](/serverless-rest-api).

```yaml
# serverless.yml

functions:
  login:
    handler: dist/auth.login
    events:
      - http:
          path: login
          method: POST
          cors: true
```

We've got a Lambda function called `login` that accepts POST requests and lives in the `auth` file.

```typescript
// dist/auth.ts

// Logs you in based on username/password combo
// Creates user on first login
export const login = async (event: APIGatewayEvent) => {
  const { username, password } = JSON.parse(event.body || "{}")

  // respond with error if username/password undefined

  // find user in database
  let user = await findUser(username)

  if (!user) {
    // user was not found, create
    user = await createUser(username, password)
  } else {
    // check credentials
    if (hashPassword(username, password) !== user.password) {
      // ðŸš¨
      return response(401, {
        status: "error",
        error: "Bad username/password combination",
      })
    }
  }

  // user was created or has valid credentials
  const token = jwt.sign(omit(user, "password"), process.env.JWT_SECRET!)

  return response(200, {
    user: omit(user, "password"),
    token,
  })
}
```

We grab `username` and `password` from request body and look for the user. `findUser` runs a database query, in our case a DynamoDB `getItem`.

If the user was not found, we create one and make sure we `hashPassword()` before saving.

If the user was found, we verify credentials by hashing the password and comparing with the stored value. We know passwords match when our `hashPassword()` method creates the same hash.

This means you can never change your `hashPassword()` method unless you force users to reset their password.

After all that's done, we sign a JWT token with our secret and send it back. Make sure you don't save sensitive data like passwords in anything that goes to the client.

```typescript
// user was created or has valid credentials
  const token = jwt.sign(omit(user, "password"), process.env.JWT_SECRET!)

  return response(200, {
    user: omit(user, "password"),
    token,
  })
```

You can [try it in the CodeSandbox](https://codesandbox.io/s/serverless-auth-example-9ipfb). Pick a username, add a password, see it work. Then try with a different password.

### `auth.verify` function

The `verify` API is used to validate a user session.

For authentication to work across page reloads, you have to store the JWT token. These can expire or get revoked by the server.

Clients decide what UI to based on whether the stored token is valid.

The `serverless.yml` definition for this function is almost the same.

```yaml
# serverless.yml

functions:
	# ...
  verify:
    handler: dist/auth.verify
    events:
      - http:
          path: verify
          method: POST
          cors: true
```

Function called `verify` that accepts POST requests and lives in `auth.ts`.

```typescript
// src/auth.ts

// Verifies you have a valid JWT token
export const verify = async (event: APIGatewayEvent) => {
  const { token } = JSON.parse(event.body || "{}")

  // respond with error if token undefined

  try {
    jwt.verify(token, process.env.JWT_SECRET!)
    return response(200, { status: "valid" })
  } catch (err) {
    return response(401, err)
  }
}
```

Verifying a JWT token with [`jsonwebtoken`](https://github.com/auth0/node-jsonwebtoken) throws an error for bad tokens. Anything from using a different secret, to tampering with the token, and expired tokens.

Clients should make this request any time they initialize and think they know a token.

### `private.hello` function

This is where it gets fun â€“Â verifying authentication for private APIs.

We make an API that says hello to the user.

```yaml
# serverless.yml

functions:
  privateHello:
    handler: dist/private.hello
    events:
      - http:
          path: private
          method: GET
          cors: true
```

Function accepts GET requests and lives in the `private.ts` file. It looks like this:

```typescript
// src/private.ts

export async function hello(event: APIGatewayEvent) {
  // returns JWT token payload
  const authorized = checkAuth(event)

  if (authorized) {
    const user = authorized as User

    return response(200, {
      message: `Hello ${user.username}`,
    })
  } else {
    return response(401, {
      status: "error",
      error: "This is a private resource",
    })
  }
}
```

The `checkAuth` method takes our request, verifies its JWT token, and returns the payload. A user in our case.

If user is authorized, we say hello, otherwise return an error.

`checkAuth` is where we read a token from the `Authorization` header and verify everything looks good.

```typescript
// src/util.ts

// Used to verify a request is authenticated
export function checkAuth(event: APIGatewayEvent): boolean | User {
  const bearer = event.headers["Authorization"]

  if (bearer) {
    try {
      const decoded = jwt.verify(
        // Bearer prefix from Authorization header
        bearer.replace(/^Bearer /, ""),
        process.env.JWT_SECRET!
      )

      // We saved user info in the token
      return decoded as User
    } catch (err) {
      return false
    }
  } else {
    return false
  }
}
```

The `Authorization` header holds our token â€“Â `Authorization: Bearer <token>`. If the header is empty, we return `false`.

We use the `jwt.verify()` call to verify the provided token was valid. This validates that it was created with our secret, wasn't tampered with, and hasn't expired.

`verify` decodes the token for us, which means we can see the user's username without a database query. ðŸ¤˜

## Use an auth provider

