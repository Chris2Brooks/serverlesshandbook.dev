export const title = "Lambdas, queues, etc"

export const description = "Learn how lambdas and queues works in the serverless approach"

export const image = "/queue.jpg"

# Elements of serverless ‚Äì¬†lambdas, queues, gateways, and more

We mentioned lambdas, queues, and other elements of serverless in previous chapters ‚Äì [Architecture Principles](/serverless-architecture-principles) and [Serverless Flavors](/serverless-flavors) ‚Äì but what *are* they? 

Let me explain.

## Lambda ‚Äì¬†a cloud function

"Lambda" comes from [lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus), a mathematical definition of functional programming Alonzo Church introduced in the 1930s. It is the alternative to Turing's [turing machines](https://en.wikipedia.org/wiki/Turing_machine) for describing a system that can [solve any solvable problem](https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis). Turing machines describe iterative step-by-step programming, lambda calculus describes functions-calling-functions functional programming.

Both approaches are equal in power.

No wonder that AWS decided to name their cloud functions AWS Lambda. As the platform's popularity grew, the word "lambda" morphed into a generic term for cloud functions and the core building block of serverless computing.

**A lambda is a function.** In this context, a function running as its own tiny server when triggered by an event.

Here's a lambda function (yes just like ATM Machine) that returns `"Hello world"` in response to an HTTP event.

```typescript
// src/handler.ts

import { APIGatewayEvent } from "aws-lambda";

export const handler = async (event: APIGatewayEvent) => {
	return {
		statusCode: 200
		body: "Hello world"
	}
}
```

A TypeScript file exports a function called `handler`. The function accepts an event and returns a response. The AWS Lambda machinery takes care of the rest.

Because this is a user-facing API method, it accepts an AWS API Gateway event and returns an HTTP style response. Status code and body.

Other providers and services will have different events and expect different responses, but **a lambda always follows this pattern üëâ function with an event and a return value.**

### Considerations with lambda functions

Your functions should follow functional programming practices:

- **idempotent** ‚Äì multiple invocations with the same inputs must produce the same result
- **pure** ‚Äì a function can't rely on anything it isn't fetching itself. Your environment does not persist, data in local memory can vanish any time. Rely on the arguments you're given and nothing else.
- **light on side-effects** ‚Äì you need *some* side-effects to make changes to your system. Make sure those come in the form of invoking other functions and services. *State inside your lambda does not persist*
- **do one thing and one thing only** ‚Äì¬†small functions focused on a single task are easiest to understand and combine

Small functions work together to produce extraordinary results. Like this example of [combining Twilio and AWS Lambda to answer the door](https://swizec.com/blog/how-i-answer-the-door-with-aws-lambda-and-twilio/swizec/9255).

### Creating lambdas

In the open source Serverless Framework, you define lambda functions with `serverless.yml` like this:

```yaml
functions:
    helloworld:
        handler: dist/helloworld.handler
        events:
            - http:
                  path: helloworld
                  method: GET
                  cors: true
```

Define a `helloworld` function and say it's handled by the `handler` method exported from the `dist/helloworld` file. Notice that we're running a build step for TypeScript so while the code is in `src/`, we run it from `dist/`.

`events` lists triggers to fire this function. An HTTP GET request on the path `/helloworld` for us.

Other common triggers include Queues, S3 changes, and CloudWatch events. At least in the AWS world.

## Queue

Queue is short for [message queue](https://en.wikipedia.org/wiki/Message_queue) ‚Äì¬†a service built on top of [queue, the data structure](https://en.wikipedia.org/wiki/Queue_(abstract_data_type)). Software engineers aren't the most inventive with names and like to overload words with many meanings ü§∑‚Äç‚ôÇÔ∏è

You can think of the queue data structure as a list of items. Enqueueing an item puts on the list, dequeueing takes it out. Typically in a guaranteed first in first out order.

![](../images/queue.png)

`enqueing` adds items at the front, `dequeing` takes them out the back. Items in the middle wait their turn.

**A messaging queue takes this data structure and scales it into a service.** 

You can find various implementations of messaging queues and they all share these core properties:

- **persistent storage** ‚Äì¬†queues have to be reliable so they store messages in some sort of database. Redis, Postgres, even a flat file. Whatever it takes to ensure that restarting the server doesn't drop those messages.
- **a periodic worker process**

## API Gateway

## Static file storage ‚Äì S3

## Static file server ‚Äì¬†CDN

## Logging 